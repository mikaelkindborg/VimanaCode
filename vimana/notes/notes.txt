
VERSION 1:

(N FACT) (N 0 EQ (1) (N 1 - FACT N *) IFELSE) DEF
(20 FACT) 100000 TIMESDO
4.33s user 0.02s system 99% cpu 4.353 total

VERSION 2:

(L N LOOP) (N 0 EQ NOT (L DO L N 1 - LOOP) IFTRUE) DEF
(N FACT) (N 0 EQ (1) (N 1 - FACT N *) IFELSE) DEF
(20 FACT) 100000 LOOP
5.37s user 0.02s system 99% cpu 5.397 total

VERSION 3:

(L N LOOP) (N 0 EQ NOT (L DO L N 1 - LOOP) IFTRUE) DEF
(N FACT) (N 0 EQ (1) (N 1 - FACT N *) IFELSE) DEF
(20 FACT) 100000 LOOP
14.93s user 0.03s system 99% cpu 14.972 total

Hejsan, har fixat med min interpretator. Har tre versioner, en "basic" som använder PHP-stacken, en med svansrekursion men fortfarande PHP-stacken för "vanlig" rekursion, och en med explicit callstack. Det funkar hyffsat bra!

Prestanda är som följer:

Version 1:
(N FACT) (N 0 EQ (1) (N 1 - FACT N *) IFELSE) DEF
(20 FACT) 100000 TIMESDO
4.33s user 0.02s system 99% cpu 4.353 total

Version 2:
(L N LOOP) (N 0 EQ NOT (L DO L N 1 - LOOP) IFTRUE) DEF
(N FACT) (N 0 EQ (1) (N 1 - FACT N *) IFELSE) DEF
(20 FACT) 100000 LOOP
5.37s user 0.02s system 99% cpu 5.397 total

Version 3:
(L N LOOP) (N 0 EQ NOT (L DO L N 1 - LOOP) IFTRUE) DEF
(N FACT) (N 0 EQ (1) (N 1 - FACT N *) IFELSE) DEF
(20 FACT) 100000 LOOP
14.93s user 0.03s system 99% cpu 14.972 total

Version 3 med callstacken tog 24 sekunder förut. Det finns mycket att vinna på att optimera PHP-koden. Funktionsanrop till exempel tar tid, så man får "inlina" kod och undvika att abstrahera så mycket och skriva långa funktioner istället för många mindre. Tabeller där uppslagning sker (PHP associativa arrayer) verkar snabba och är framförallt snabba när man kopierar dom ("copy on write"). Det gör att uppslagningar verkar gå hyffsat fort. 

Min plan nu är att göra en mer optimerad version av version 3. Jag undrar om det är någon generell "regel" att det är snabbare att använda implementationsspråkets callstack? Chicken Scheme gör ju det till exempel, vad jag förstår. Men det blir roligare med en egen callstack för man kan göra diverse hyss och sen även göra parallella processer tänker jag.

Ursäkta excessen i uppercase, det är gammal nostalgi. Man kan ju göra som man vill själv genom att modda primitiven. Det är meningen att det ska vara lätt att lägga till primitiv, och primitiven är helt fristående från interpretatorn. Kör man utan primitiv hamnar alla element i programmet på datastacken! Själva interpretatorn och parsern är ca 160 rader för v1, ca 215 för v2 och ca 290 för v3. Sen är nuvarande primitiv runt 350 rader men det kan man ju så klart utveckla mycket mer.
